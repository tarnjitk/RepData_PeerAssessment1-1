
---
title: 'Reproducible Research: Peer Assessment 1'
output:
  html_document:
    keep_md: yes
  pdf_document: default
---

## Introduction

It is now possible to collect a large amount of data about personal movement using activity monitoring devices such as a Fitbit, Nike Fuelband, or Jawbone Up. These type of devices are part of the “quantified self” movement – a group of enthusiasts who take measurements about themselves regularly to improve their health, to find patterns in their behavior, or because they are tech geeks. But these data remain under-utilized both because the raw data are hard to obtain and there is a lack of statistical methods and software for processing and interpreting the data.

## Data Processing and Analysis

The source of the data used in this study is provided by [here](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip)

```{r echo = TRUE, results = "hide", warning = FALSE, message = FALSE}
        require(dplyr)
        require(ggplot2)
        require(data.table)
        require(scales)
        require(lubridate)
        activityData <- read.csv("activity.csv", 
                                 header = TRUE, 
                                 na.strings = "NA",
                                 stringsAsFactors=FALSE)

        activityData1 <- data.table(activityData)
        activityData$date <- as.Date(activityData$date, "%Y-%m-%d") 
        dayOfWeek <- weekdays(activityData$date)
        activityData <- cbind(activityData, dayOfWeek)
        activityData <- activityData[which(complete.cases(activityData)),]
```


## Summary of Data Analysis

### The mean total number of steps taken per day

```{r}
      sumStepsPerDay <- aggregate(activityData$steps, by = list(activityData$date), sum)
        hist(sumStepsPerDay$x, breaks = 50,
                col = "blue", border = NULL,
                main = "Histogram of the total number of steps taken each day",
                xlab = "Total number of steps taken each day")
```

The distribution of the total number of steps taken per day appear to follow normal behaviour, where the mean of the total number of steps taken per day is `r round(mean(sumStepsPerDay$x, na.rm = TRUE),2)` and median number of steps taken each day is `r median(sumStepsPerDay$x, na.rm = TRUE)`.
```{r}
         mean(sumStepsPerDay$x, na.rm = TRUE)
```


```{r}
         median(sumStepsPerDay$x, na.rm = TRUE)
```

### The average daily activity pattern
In order to depict the average daily activity pattern, a time series graph of the average steps through the time-span of a day, that is, the mean number of steps for each of the 5 minute time intervals over the 24 hour period, is presented.
Here the summary variable is the number of steps and the grouping variable is the interval.

```{r echo = TRUE, results = "hide", warning = FALSE, message = FALSE}
        
        activityTimeSeries <- aggregate(activityData$steps, by = list(activityData$interval), 
                        mean)
        colnames(activityTimeSeries) <- c("Time", "MeanNumberOfSteps")
        activityTimeSeries$Time <- activityTimeSeries$Time/100 # to convert the time interval to hours
        ggplot(activityTimeSeries, aes(x=Time, y=MeanNumberOfSteps)) + geom_line() + xlab("Time(Hours)") + ylab("Mean number of steps")
```


The 5-minute interval, on average across all the days in the dataset, which contains the maximum number of steps is at `r ` in the morning, as given by
```{r}
        print(activityTimeSeries[which.max(activityTimeSeries$MeanNumberOfSteps),])
```


### The difference in activity patterns between weekdays and weekends

The graph below depicts the difference in the weekday (red plot) and weekend (blue) activity patterns.
```{r echo = TRUE, results = "hide", warning = FALSE, message = FALSE}
        WE <- c("Sunday","Saturday")
        WD <- c("Monday","Tuesday", "Wednesday","Thursday","Friday")

        dayType <- ifelse(activityData$dayOfWeek %in% WD, "weekday", "weekend")
        activityData <- cbind(activityData, dayType)
  
         activityDataWD <- filter(activityData, activityData$dayType == "weekday")
 
         activityDataWE <- filter(activityData, activityData$dayType == "weekend")
 
        activityTimeSeriesWD <- aggregate(activityDataWD$steps, 
                         by = list(activityDataWD$interval), mean)
 
        activityTimeSeriesWE <- aggregate(activityDataWE$steps, 
                        by = list(activityDataWE$interval), mean)

        colnames(activityTimeSeriesWE) <- c("Time", "MeanNumberOfStepsWE")
        activityTimeSeriesWE$Time <- activityTimeSeriesWE$Time/100 

        colnames(activityTimeSeriesWD) <- c("Time", "MeanNumberOfStepsWD")
        activityTimeSeriesWD$Time <- activityTimeSeriesWD$Time/100 # to convert the time interval to hours
# 


#         activityTimeSeriesWE <- aggregate(activityDTWE$steps, by = list(activityDTWE$interval), 
#                         mean)
# 
#         activityDTWE <- activityData[which(dayOfWeek %in% weekend),]

#         activityTimeSeriesWE <- aggregate(activityDTWE$steps, by = list(activityDTWE$interval), 
#                         mean)
#         # to convert the time interval to hours
# 
#         activityDTWD <- activityData[which(dayOfWeek %in% weekday),]
#         activityTimeSeriesWD <- aggregate(activityDTWD$steps, by = list(activityDTWD$interval), 
#                         mean)
# 
         activityTimeSeries <- merge(activityTimeSeriesWD, activityTimeSeriesWE, "Time")
 
        ggplot(activityTimeSeries, aes(x=Time, y=MeanNumberOfStepsWD, color = "Weekdays")) + geom_line() + xlab("Time(Hours)") + ylab("Mean number of steps") +   geom_line(aes(x=Time, y=MeanNumberOfStepsWE, color = "Weekends")) + scale_colour_manual("", breaks = c("Weekdays", "Weekends"), values = c("red", "blue"))
```

```{r}
        numOfMissing <- sum(is.na(activityData1$steps))
        print(numOfMissing)
```


There are a total of `r numOfMissing ` missing values in the dataset (i.e. the total number of rows with NAs).


















